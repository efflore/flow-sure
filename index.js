var I=(z)=>typeof z==="function",Z=(z)=>z!=null,g=(z)=>typeof z==="object"&&Z(z),S=(z,B)=>g(z)&&z[Symbol.toStringTag]===B,_=(z)=>S(z,"Ok"),$=(z)=>S(z,"Nil"),U=(z)=>S(z,"Err"),q=(z)=>_(z)||$(z),A=(z)=>_(z)||$(z)||U(z),H=(z)=>U(z)?z:L(z),V=(z)=>K(z instanceof Error?z:new Error(String(z))),G=(z)=>({[Symbol.toStringTag]:"Ok",value:z,map:(B)=>G(B(z)),chain:(B)=>B(z),filter:(B)=>B(z)?G(z):C(),guard:(B)=>B(z)?G(z):C(),or:()=>G(z),catch:()=>G(z),match:(B)=>I(B.Ok)?B.Ok(z):G(z),get:()=>z}),C=()=>({[Symbol.toStringTag]:"Nil",map:C,chain:C,filter:C,guard:C,or:(z)=>L(z()),catch:C,match:(z)=>I(z.Nil)?z.Nil():C(),get:()=>{return}}),K=(z)=>({[Symbol.toStringTag]:"Err",error:z,map:()=>K(z),chain:()=>K(z),filter:C,guard:C,or:(B)=>L(B()),catch:(B)=>B(z),match:(B)=>I(B.Err)?B.Err(z):V(z),get:()=>{throw z}}),L=(z)=>!Z(z)?C():q(z)?z:G(z),M=(z)=>{try{let B=z();return H(B)}catch(B){return V(B)}},x=async(z,B=0,J=1000)=>{let W=async(X,Y)=>{return Promise.resolve(z()).then((Q)=>H(Q)).catch(async(Q)=>{if(X<1)return V(Q);return await new Promise((P)=>setTimeout(P,Y)),W(X-1,Y*2)})};return await W(B,J)};async function m(...z){let B=I(z[0])?C():L(z.shift());for(let J of z){if(U(B))break;if(!I(J))return K(new TypeError("Expected a function in flow"));B=await x(()=>J(B.get()))}return B}export{A as isResult,_ as isOk,S as isObjectOfType,$ as isNil,q as isMaybe,I as isFunction,U as isErr,g as isDefinedObject,Z as isDefined,x as gather,m as flow,L as ensure,M as attempt,G as Ok,C as Nil,K as Err};
