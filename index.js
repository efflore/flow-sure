var S=(h)=>h!=null,V=(h)=>typeof h==="object"&&S(h),L=(h,z)=>V(h)&&h[Symbol.toStringTag]===z,W=(h)=>L(h,"Ok"),X=(h)=>L(h,"Nil"),Y=(h)=>L(h,"Err"),_=(h)=>W(h)||X(h)||Y(h),G=(h)=>typeof h==="function",Z=(h,...z)=>G(h)?h(...z):void 0,B=(h)=>({[Symbol.toStringTag]:"Ok",value:h,map:(z)=>B(z(h)),chain:(z)=>z(h),filter:(z)=>z(h)?B(h):A(),guard:(z)=>z(h)?B(h):A(),or:()=>B(h),catch:()=>B(h),match:(z)=>G(z.Ok)?z.Ok(h):B(h),get:()=>h}),A=()=>({[Symbol.toStringTag]:"Nil",map:A,chain:A,filter:A,guard:A,or:(h)=>I(h),catch:A,match:(h)=>G(h.Nil)?h.Nil():A(),get:()=>{return}}),C=(h)=>({[Symbol.toStringTag]:"Err",error:h,map:()=>C(h),chain:()=>C(h),filter:A,guard:A,or:(z)=>I(z),catch:(z)=>z(h),match:(z)=>G(z.Err)?z.Err(h):C(h),get:()=>{throw h}}),I=(h)=>S(h)?B(h):A(),$=(h)=>{try{return I(h())}catch(z){return C(z)}},q=async(h,z=0,J=1000)=>{let M=async(P,Q)=>{return h().then((K)=>I(K)).catch(async(K)=>{if(P<1)return C(K);return await new Promise((U)=>setTimeout(U,Q)),M(P-1,Q*2)})};return await M(z,J)},x=(...h)=>h.reduce((z,J)=>Z(J,z));export{q as task,$ as result,I as option,_ as isResult,W as isOk,L as isObjectOfType,X as isNil,G as isFunction,Y as isErr,V as isDefinedObject,S as isDefined,x as flow,Z as callFunction,B as Ok,A as Nil,C as Err};
