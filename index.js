var G=(z)=>typeof z==="function",Y=(z)=>z!=null,x=(z)=>typeof z==="object"&&Y(z),P=(z,A)=>x(z)&&z[Symbol.toStringTag]===A,Z=(z)=>P(z,"Ok"),_=(z)=>P(z,"Nil"),Q=(z)=>P(z,"Err"),H=(z)=>Z(z)||_(z),U=(z)=>Z(z)||_(z)||Q(z),$=(z)=>Q(z)?z:K(z),S=(z)=>J(z instanceof Error?z:new Error(String(z))),C=(z)=>({[Symbol.toStringTag]:"Ok",value:z,map:(A)=>C(A(z)),chain:(A)=>A(z),filter:(A)=>A(z)?C(z):B(),guard:(A)=>A(z)?C(z):B(),or:()=>C(z),catch:()=>C(z),match:(A)=>G(A.Ok)?A.Ok(z):C(z),get:()=>z}),B=()=>({[Symbol.toStringTag]:"Nil",map:B,chain:B,filter:B,guard:B,or:(z)=>K(z()),catch:B,match:(z)=>G(z.Nil)?z.Nil():B(),get:()=>{return}}),J=(z)=>({[Symbol.toStringTag]:"Err",error:z,map:()=>J(z),chain:()=>J(z),filter:B,guard:B,or:(A)=>K(A()),catch:(A)=>A(z),match:(A)=>G(A.Err)?A.Err(z):S(z),get:()=>{throw z}}),K=(z)=>!Y(z)?B():H(z)?z:C(z),g=(z)=>{try{let A=z();return $(A)}catch(A){return S(A)}},R=async(z,A=0,I=1000)=>{let V=async(W,X)=>{return Promise.resolve(z()).then((L)=>$(L)).catch(async(L)=>{if(W<1)return S(L);return await new Promise((q)=>setTimeout(q,X)),V(W-1,X*2)})};return await V(A,I)};async function h(...z){let A=G(z[0])?B():K(z.shift());for(let I of z){if(Q(A))break;if(!G(I))return J(new TypeError("Expected a function in flow"));A=await R(()=>I(A))}return A}export{U as isResult,Z as isOk,P as isObjectOfType,_ as isNil,H as isMaybe,G as isFunction,Q as isErr,x as isDefinedObject,Y as isDefined,R as gather,h as flow,K as ensure,g as attempt,C as Ok,B as Nil,J as Err};
