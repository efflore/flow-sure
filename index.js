var X=(h)=>h!=null,q=(h)=>typeof h==="object"&&X(h),L=(h,z)=>q(h)&&h[Symbol.toStringTag]===z,Y=(h)=>L(h,"Ok"),Z=(h)=>L(h,"Nil"),P=(h)=>L(h,"Err"),x=(h)=>Y(h)||Z(h),R=(h)=>Y(h)||Z(h)||P(h),_=(h)=>P(h)?h:J(h),Q=(h)=>I(h instanceof Error?h:new Error(String(h))),B=(h)=>typeof h==="function",U=(h,...z)=>B(h)?h(...z):void 0,C=(h)=>({[Symbol.toStringTag]:"Ok",value:h,map:(z)=>C(z(h)),chain:(z)=>z(h),filter:(z)=>z(h)?C(h):A(),guard:(z)=>z(h)?C(h):A(),or:()=>C(h),catch:()=>C(h),match:(z)=>B(z.Ok)?z.Ok(h):C(h),get:()=>h}),A=()=>({[Symbol.toStringTag]:"Nil",map:A,chain:A,filter:A,guard:A,or:(h)=>J(h()),catch:A,match:(h)=>B(h.Nil)?h.Nil():A(),get:()=>{return}}),I=(h)=>({[Symbol.toStringTag]:"Err",error:h,map:()=>I(h),chain:()=>I(h),filter:A,guard:A,or:(z)=>J(z()),catch:(z)=>z(h),match:(z)=>B(z.Err)?z.Err(h):Q(h),get:()=>{throw h}}),J=(h)=>!X(h)?A():x(h)?h:C(h),H=(h)=>{try{let z=h();return _(z)}catch(z){return Q(z)}},g=async(h,z=0,G=1000)=>{let S=async(V,W)=>{return h().then((K)=>_(K)).catch(async(K)=>{if(V<1)return Q(K);return await new Promise(($)=>setTimeout($,W)),S(V-1,W*2)})};return await S(z,G)};async function M(...h){let z=B(h[0])?A():J(h.shift());for(let G of h){if(!B(G))return I(new TypeError("Expected function in flow"));if(P(z))break;if(z=H(B(z.then)?async()=>await z.then(G):()=>G(z)),z&&B(z.then))await z}return z}export{g as obtain,R as isResult,Y as isOk,L as isObjectOfType,Z as isNil,x as isMaybe,B as isFunction,P as isErr,q as isDefinedObject,X as isDefined,M as flow,J as ensure,U as callFunction,H as attempt,C as Ok,A as Nil,I as Err};
