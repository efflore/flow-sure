var M=Object.defineProperty;var Z=(x,S)=>{for(var G in S)M(x,G,{get:S[G],enumerable:!0,configurable:!0,set:(C)=>S[G]=()=>C})};var H=(x)=>typeof x==="function";var V=(x)=>(S)=>S instanceof x,X=(x)=>V(Error)(x),Q=function(){return this};var $={};Z($,{of:()=>W,isMaybe:()=>_});var W=(x)=>x==null?B.of():_(x)?x:q.of(x),_=(x)=>q.isOk(x)||B.isNil(x);class B{static instance=new B;static of=()=>B.instance;static isNil=(x)=>x===B.instance;get=()=>{return}}var J=B.prototype;J.map=J.chain=J.filter=J.guard=J.catch=Q;J.or=(x)=>W(x());J.match=function(x){return H(x.Nil)?x.Nil():this};class q{x;constructor(x){this.value=x}static of=(x)=>new q(x);static isOk=V(q);get(){return this.value}}var K=q.prototype;K.map=function(x){return new q(x(this.value))};K.chain=function(x){return x(this.value)};K.filter=K.guard=function(x){return x(this.value)?this:B.of()};K.or=K.catch=Q;K.match=function(x){return H(x.Ok)?x.Ok(this.value):this};class z{x;constructor(x){this.error=x}static of=(x)=>new z(X(x)?x:new Error(String(x)));static isErr=V(z);get(){throw this.error}}var L=z.prototype;L.map=L.chain=Q;L.filter=L.guard=()=>B.of();L.or=(x)=>W(x());L.catch=function(x){return x(this.error)};L.match=function(x){return H(x.Err)?x.Err(this.error):this};var A={};Z(A,{unwrap:()=>I,of:()=>Y,isResult:()=>m,fromAsync:()=>D,from:()=>j,flow:()=>U});var Y=(x)=>x==null?B.of():m(x)?x:X(x)?z.of(x):q.of(x),j=(x,...S)=>{try{return Y(x(...S))}catch(G){return z.of(G)}},D=async(x,...S)=>{try{return Y(await x(...S))}catch(G){return z.of(G)}},m=(x)=>q.isOk(x)||B.isNil(x)||z.isErr(x),U=async(...x)=>{let S=H(x[0])?B.of():Y(x.shift());for(let G of x){if(z.isErr(S))break;if(!H(G))return z.of(new TypeError("Expected a function in flow"));S=/^async\s+/.test(G.toString())?await D(async()=>G(S.get())):j(G,S.get())}return S},I=(x)=>z.isErr(x)?x.error:q.isOk(x)||B.isNil(x)?x.get():x;export{A as Result,q as Ok,B as Nil,$ as Maybe,z as Err};
