var W=(g)=>typeof g==="function",D=(g)=>W(g)&&g.prototype.constructor.name==="AsyncFunction",q=(g)=>g!=null,_=(g)=>(G)=>G instanceof g,$=function(){return this};class K{g;constructor(g){this.value=g}static of=(g)=>new K(g);static isOk=_(K);get(){return this.value}}var U=K.prototype;U.map=function(g){return new K(g(this.value))};U.chain=function(g){return g(this.value)};U.filter=U.guard=function(g){return g(this.value)?this:C.of()};U.or=U.catch=$;U.match=function(g){return W(g.Ok)?g.Ok(this.value):this};class C{static instance=new C;constructor(){}static of=()=>C.instance;static isNil=(g)=>g===C.instance;get(){return}}var S=C.prototype;S.map=S.chain=S.filter=S.guard=S.catch=$;S.match=function(g){return W(g.Nil)?g.Nil():this};class J{g;constructor(g){this.error=g}static of=(g)=>new J(g instanceof Error?g:new Error(String(g)));static isErr=_(J);get(){throw this.error}}var V=J.prototype;V.map=V.chain=$;V.filter=V.guard=function(){return C.of()};S.or=V.or=function(g){return Y.of(g())};V.catch=function(g){return console.debug(this),g(this.error)};V.match=function(g){return W(g.Err)?g.Err(this.error):this};var Y;((L)=>(L.of=(B)=>!q(B)?C.of():L.isMaybe(B)?B:K.of(B),L.isMaybe=(B)=>K.isOk(B)||C.isNil(B),L.unwrap=(B)=>L.isMaybe(B)?B.get():B))(Y||={});var Z;((z)=>(z.of=(j)=>!q(j)?C.of():z.isResult(j)?j:_(Error)(j)?J.of(j):K.of(j),z.from=(j)=>{try{return z.of(j())}catch(X){return J.of(X)}},z.fromAsync=async(j,X=0,H=1000)=>{try{return z.of(await j())}catch(w){if(X<1)return J.of(w);return await new Promise((x)=>setTimeout(x,H)),z.fromAsync(j,X-1,H*2)}},z.isResult=(j)=>K.isOk(j)||C.isNil(j)||J.isErr(j),z.unwrap=(j)=>J.isErr(j)?j.error:Y.unwrap(j)))(Z||={});async function m(...g){let G=W(g[0])?C.of():Y.of(g.shift());for(let Q of g){if(J.isErr(G))break;if(!W(Q))return J.of(new TypeError("Expected a function in flow"));G=D(Q)?await Z.fromAsync(async()=>Q(G.get())):Z.from(()=>Q(G.get()))}return G}export{W as isFunction,q as isDefined,D as isAsyncFunction,m as flow,Z as Result,K as Ok,C as Nil,Y as Maybe,J as Err};
