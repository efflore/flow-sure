var J=(x)=>typeof x==="function";var Y=(x)=>(G)=>G instanceof x,_=(x)=>Y(Error)(x),X=function(){return this};class B{static instance=new B;static of=()=>B.instance;static isNil=(x)=>x===B.instance;get=()=>{return}}var Q=B.prototype;Q.map=Q.chain=Q.filter=Q.guard=Q.catch=X;Q.or=(x)=>K(x());Q.match=function(x){return J(x.Nil)?x.Nil():this};class z{x;constructor(x){this.value=x}static of=(x)=>new z(x);static isOk=Y(z);get(){return this.value}}var V=z.prototype;V.map=function(x){return new z(x(this.value))};V.chain=function(x){return x(this.value)};V.filter=V.guard=function(x){return x(this.value)?this:B.of()};V.or=V.catch=X;V.match=function(x){return J(x.Ok)?x.Ok(this.value):this};var K=(x)=>x==null?B.of():D(x)?x:z.of(x),D=(x)=>z.isOk(x)||B.isNil(x);class S{x;constructor(x){this.error=x}static of=(x)=>new S(_(x)?x:new Error(String(x)));static isErr=Y(S);get(){throw this.error}}var W=S.prototype;W.map=W.chain=X;W.filter=W.guard=()=>B.of();W.or=(x)=>K(x());W.catch=function(x){return x(this.error)};W.match=function(x){return J(x.Err)?x.Err(this.error):this};var $=(x)=>x==null?B.of():H(x)?x:_(x)?S.of(x):z.of(x),j=(x)=>{try{return $(x())}catch(G){return S.of(G)}},Z=async(x,G=0,L=1000)=>{try{return $(await x())}catch(m){if(G<1)return S.of(m);return await new Promise((q)=>setTimeout(q,L)),Z(x,G-1,L*2)}},H=(x)=>z.isOk(x)||B.isNil(x)||S.isErr(x),g=(x)=>S.isErr(x)?x.error:z.isOk(x)||B.isNil(x)?x.get():x;var C=async(...x)=>{let G=J(x[0])?B.of():K(x.shift());for(let L of x){if(S.isErr(G))break;if(!J(L))return S.of(new TypeError("Expected a function in flow"));G=/^async\s+/.test(L.toString())?await Z(async()=>L(G.get())):j(()=>L(G.get()))}return G};var a={of:K,isMaybe:D},l={of:$,from:j,fromAsync:Z,isResult:H,unwrap:g};export{C as flow,l as Result,z as Ok,B as Nil,a as Maybe,S as Err};
