var X="Ok",Z="Nil",$="Err",V=(b)=>b!=null,q=(b)=>b[Symbol.toStringTag]==="Ok",x=(b)=>b[Symbol.toStringTag]==="Err",H=(b)=>b[Symbol.toStringTag]==="Nil",I=(b)=>["Ok","Nil","Err"].includes(b[Symbol.toStringTag]),B=(b)=>typeof b==="function",W=(b,...h)=>B(b)?b(...h):void 0,z=(b)=>({[Symbol.toStringTag]:"Ok",value:b,map:(h)=>z(h(b)),flatMap:(h)=>h(b),filter:(h)=>h(b)?z(b):j(),guard:(h)=>h(b)?z(b):j(),or:()=>z(b),catch:()=>z(b),match:(h)=>B(h.Ok)?h.Ok(b):z(b),get:()=>b}),j=()=>({[Symbol.toStringTag]:"Nil",map:j,flatMap:j,filter:j,guard:j,or:(b)=>C(b),catch:j,match:(b)=>B(b.Nil)?b.Nil():j(),get:()=>{return}}),A=(b)=>({[Symbol.toStringTag]:"Err",error:b,map:()=>A(b),flatMap:()=>A(b),filter:j,guard:j,or:(h)=>C(h),catch:(h)=>h(b),match:(h)=>B(h.Err)?h.Err(b):A(b),get:()=>{throw b}}),C=(b)=>V(b)?z(b):j(),K=(b)=>{try{return C(b())}catch(h){return A(h)}},L=async(b,h=0,G=1000)=>{let M=async(Q,S)=>{return b().then((J)=>C(J)).catch(async(J)=>{if(Q<1)return A(J);return await new Promise((U)=>setTimeout(U,S)),M(Q-1,S*2)})};return await M(h,G)},g=(...b)=>b.reduce((h,G)=>W(G,h));export{L as task,K as result,C as option,I as isResult,q as isOk,H as isNil,B as isFunction,x as isErr,V as isDefined,g as flow,W as callFunction,X as TYPE_OK,Z as TYPE_NIL,$ as TYPE_ERR,z as Ok,j as Nil,A as Err};
