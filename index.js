var g="Ok",h="Nil",w="Err",$=(z)=>z!=null,W=(z)=>(A)=>$(A)&&(Symbol.toStringTag in A)&&A[Symbol.toStringTag]===z,H=W("Ok"),I=W("Nil"),K=W("Err"),C=(z)=>H(z)||I(z)||K(z),q=(z)=>typeof z==="function",L=(z,...A)=>q(z)?z(...A):void 0,X=(z,A,M)=>(Q)=>{let S=Q[z]??Q.else;return q(S)?S(A):M},J=(z)=>({[Symbol.toStringTag]:"Ok",value:z,map:(A)=>U(A(z)),flatMap:(A)=>A(z),filter:(A)=>A(z)?J(z):B(),guard:(A)=>A(z)?J(z):B(),or:()=>J(z),catch:()=>J(z),match:X("Ok",z,J(z)),get:()=>z}),B=()=>({[Symbol.toStringTag]:"Nil",map:B,flatMap:B,filter:B,guard:B,or:U,catch:B,match:X("Nil",void 0,B()),get:()=>{return}}),G=(z)=>({[Symbol.toStringTag]:"Err",error:z,map:()=>G(z),flatMap:()=>G(z),filter:()=>G(z),guard:()=>G(z),or:(A)=>U(A),catch:(A)=>A(z),match:X("Err",z,G(z)),get:()=>{throw z}}),U=(z)=>$(z)?J(z):B(),D=(z)=>{try{return U(z())}catch(A){return G(A)}},P=async(z,A=0,M=1000)=>{let Q=async(S,Z)=>{return z().then((V)=>U(V)).catch(async(V)=>{if(S<1)return G(V);return await new Promise((x)=>setTimeout(x,Z)),Q(S-1,Z*2)})};return await Q(A,M)},R=(...z)=>z.reduce((A,M)=>L(M,A));export{P as task,D as result,U as option,C as isResult,H as isOk,W as isObjectOfType,I as isNil,q as isFunction,K as isErr,$ as isDefined,R as flow,L as callFunction,g as TYPE_OK,h as TYPE_NIL,w as TYPE_ERR,J as Ok,B as Nil,G as Err};
