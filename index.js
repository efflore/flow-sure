var x=(y)=>typeof y==="function",Q=(y)=>x(y)&&(y.constructor.name==="AsyncFunction"||/^\s*async\s+/.test(y.toString())),Y=(y)=>y!=null,C=(y)=>typeof y==="object"&&y!==null,j=(y)=>(o)=>o instanceof y,L=j(Error),V=(y,o=console.log)=>(...p)=>{return o(y,...p),p[0]},S=(y,o=!0)=>{if(!C(y))return y;try{return structuredClone(y)}catch{if(o)V("Failed to clone value:",console.warn)(y);return y}};var A=(y)=>y==null?T():W(y)?y:F(y),W=(y)=>D(y)||B(y);class q{static instance=new q;map(y){return this}chain(y){return this}async await(y){return this}filter(y){return this}guard(y){return this}catch(y){return this}or=(y)=>A(y());match(y){return x(y.Nil)?y.Nil():this}get=()=>{}}var T=()=>q.instance,B=(y)=>y===q.instance;var G=(y,...o)=>{try{return I(y(...o))}catch(p){return g(p)}},H=async(y,...o)=>{try{return I(await y(...o))}catch(p){return g(p)}},Z=async(...y)=>{let o=x(y[0])?T():I(y.shift());for(let p of y){if(K(o))break;if(!x(p))return g(new TypeError("Expected a function in flow"));o=Q(p)?await H(async()=>p(o.get())):G(p,o.get())}return o},$=(y)=>D(y)||B(y)||K(y),I=(y)=>K(y)?y:L(y)?g(y):A(y),M=(y)=>K(y)?y.error:D(y)||B(y)?y.get():y;class J{y;constructor(y){this.error=y}map(y){return this}chain(y){return this}async await(y){return this}filter=(y)=>T();guard=(y)=>T();or=(y)=>A(y(this.error));catch=(y)=>G(()=>y(this.error));match(y){return x(y.Err)?y.Err(this.error):this}get(){throw this.error}}var g=(y)=>new J(L(y)?y:new Error(String(y))),K=j(J);var z=new ReferenceError("Mutable reference has already been consumed"),X=Symbol();class P{value;mut;constructor(y){this.value=S(y,!1),this.mut=C(y)}get gone(){return this.value===X}map(y){if(this.gone)throw z;return F(y(this.value))}chain(y){return this.gone?g(z):G(()=>y(this.value))}async await(y){return this.gone?Promise.resolve(g(z)):H(()=>y(this.value))}filter(y){return!this.gone&&y(this.value)?this:T()}guard(y){return this.filter(y)}or(y){return this}catch(y){return this}match(y){if(this.gone)return x(y.Gone)?y.Gone():g(z);return x(y.Ok)?y.Ok(this.value):this}get(){if(this.gone)throw z;let y=this.value;if(this.mut)this.value=X;return y}}var F=(y)=>new P(y),D=j(P),d=(y)=>D(y)&&y.gone;export{I as wrap,M as unwrap,S as tryClone,H as task,G as result,F as ok,T as nil,A as maybe,V as log,$ as isResult,D as isOk,B as isNil,C as isMutable,W as isMaybe,j as isInstanceOf,d as isGone,x as isFunction,L as isError,K as isErr,Y as isDefined,Q as isAsyncFunction,Z as flow,g as err,P as Ok,q as Nil,J as Err};
